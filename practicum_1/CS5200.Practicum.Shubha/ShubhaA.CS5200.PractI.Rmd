---
title: "Analysis of Wildlife Strikes in Commercial Aviation"
author: "Shubha, Adithya"
email: "shubha.a@northeastern.edu"
date: "`r Sys.Date()`"
output:
  html_document:
    df_print: paged
subtitle: Practicum I CS5200
---


```{r cleanEnvironment, echo=FALSE,warning=FALSE, eval= TRUE}
# Cleans the environment before beginning the execution
# referredFrom:https://northeastern.instructure.com/courses/192346/assignments/2351524
rm(list = ls())
```

```{r installAndLoadRequiredPackages, echo=FALSE,warning=FALSE, eval= TRUE}
# Install program required packages
# Installs RMysql, DBI and testthat,kableExtra,jsonlite packages
# referredFrom: http://artificium.us/lessons/06.r/l-6-104-r4progs/l-6-104.html#Install_Packages_on_Demand
installRequiredPackages <- function() {
  packages <- c("RMySQL", "DBI", "testthat", "kableExtra", "jsonlite")
  # Install packages that are not installed
  installed_packages <- packages %in% rownames(installed.packages())
  if (any(installed_packages == FALSE)) {
    install.packages(packages[!installed_packages])
  }
}

# Loads the required packages to the environment
# Loads RMysql, DBI,kableExtra and testthat packages
loadRequiredPackages <- function() {
  suppressMessages({
    library(RMySQL)
    library(DBI)
    library(kableExtra)
    library(testthat)
    library(jsonlite)
  })
}
installRequiredPackages()
loadRequiredPackages()
```

## Connecting to a MySql Database
```{r connectToDatabase, echo=TRUE,warning=FALSE, eval= TRUE}
# Part 3: Connecting to the database

# Function to connect to the database
# @return: database connection
# referredFrom: http://artificium.us/lessons/06.r/l-6-301-sqlite-from-r/l-6-301.html#Connect_to_Database
connectToDatabase <- function() {
  # DB credentials
  dbName <- "defaultdb"
  dbUser <- "avnadmin"
  dbPassword <- "AVNS_LfgR_-4_x2xF-vv7_Bg"
  dbHost <- "practicum-1-cs-5200.b.aivencloud.com"
  dbPort <- 22694
  
  
  return (
    dbConnect(
      RMySQL::MySQL(),
      user = dbUser,
      password = dbPassword,
      dbname = dbName,
      host = dbHost,
      port = dbPort
    )
  )
}
```

```{r globalVariables, echo=FALSE,warning=FALSE, eval=TRUE}
# Define all the global variables used in the code

# Global variable to connect to the database
dbCon <- connectToDatabase()


# Global variables defining list of tables used throughout the code.
# Adding double quotes to process dot(.) in table name.
widlifeStrikesTableName <- paste0('"', "wildlife.strikes", '"')
flightsTableName <- 'flights'
airportsTableName <- 'airports'
conditionsTableName <- 'conditions'
wildlifeSizeTableName <- 'wildlifeSize'
updateLog <- 'update_log'
```

```{r dropAllExistingTables, echo=FALSE,warning=FALSE, eval= TRUE}
# SQL query to drop the given table if it exists.
# @param: table - table to drop
dropTableIfExist <- function(table) {
  return (sprintf("DROP TABLE IF EXISTS %s", table))
}

# Drops all the existing tables of program from a given db connection.
# @param: dbCon - database connection to connect to
dropAllExistingTable <- function(dbCon) {
  tables <- c(
    widlifeStrikesTableName,
    flightsTableName,
    airportsTableName,
    conditionsTableName,
    wildlifeSizeTableName,
    updateLog
  )
  for (table in tables) {
    # Using invisible to prevent knitting of the output
    # referredFrom: https://www.geeksforgeeks.org/invisible-function-in-r/
    invisible(dbExecute(dbCon, dropTableIfExist(table)))
  }
}

dropAllExistingTable(dbCon)
```

## Create Tables In Database
``` {r createTables , echo=TRUE,warning=FALSE, eval= TRUE}
# Part 4: Creating tables in the database

# Creates flight table in database
# @param: dbCon - database connection to connect to
createFlight <- function(dbCon) {
  query <- sprintf(
    "CREATE TABLE IF NOT EXISTS %s(
    fid INT PRIMARY KEY AUTO_INCREMENT,
    date DATE,
    originAirport INT NOT NULL,
    airlineName TEXT NOT NULL,
    aircraftType TEXT NOT NULL,
    isHeavy BOOLEAN,
    FOREIGN KEY (originAirport) REFERENCES %s(aid)
);",
flightsTableName,
airportsTableName
  )
  invisible(dbExecute(dbCon, query))
}

# Creates airport table in database
# @param: dbCon - database connection to connect to
createAirports <- function(dbCon) {
  # Adding not null constriant to ensure data inserted is clean.
  query <- sprintf(
    "CREATE TABLE IF NOT EXISTS %s (
    aid INT PRIMARY KEY AUTO_INCREMENT,
    airportName TEXT NOT NULL,
    airportState TEXT NOT NULL,
    airportCode VARCHAR(5) NOT NULL DEFAULT 'ZZZ'
    );",
    airportsTableName
  )
  invisible(dbExecute(dbCon, query))
}

# Creates condition table in database
# @param: dbCon - database connection to connect to
createConditions <- function(dbCon) {
  # Text cannot have default values
  query <- sprintf(
    "CREATE TABLE IF NOT EXISTS %s (
    cid INT PRIMARY KEY AUTO_INCREMENT,
    sky_condition TEXT NOT NULL,
    explanation TEXT
);",
conditionsTableName
  )
  invisible(dbExecute(dbCon, query))
}

# Create wildlife size table in database
# @param: dbCon - database connection to connect to
createWildLifeSize <- function(dbCon) {
  # Adding not null constriant to ensure data inserted is clean.
  query <- sprintf(
    "CREATE TABLE IF NOT EXISTS %s (
    wlId INT PRIMARY KEY AUTO_INCREMENT,
    size TEXT NOT NULL);",
    wildlifeSizeTableName
  )
  invisible(dbExecute(dbCon, query))
}

# Create wildlife.strikes table in database
# @param: dbCon - database connection to connect to
createWildLifeStrikes <- function(dbCon) {
  query <- sprintf(
    "CREATE TABLE IF NOT EXISTS %s (
    iid INT PRIMARY KEY AUTO_INCREMENT,
    fid INT NOT NULL,
    wlsize INT NOT NULL,
    impact TEXT NOT NULL,
    altitude INT NOT NULL CHECK (altitude >= 0),
    conditions INT NOT NULL,
    FOREIGN KEY (fid) REFERENCES %s(fid),
    FOREIGN KEY (wlsize) REFERENCES %s(wlId),
    FOREIGN KEY (conditions) REFERENCES %s(cid)
);",
widlifeStrikesTableName,
flightsTableName,
wildlifeSizeTableName,
conditionsTableName
  )
  invisible(dbExecute(dbCon, query))
}

# Create all tables in the database.
# @param: dbCon - database connection to connect to
createAllTables <- function(dbCon) {
  createAirports(dbCon)
  createFlight(dbCon)
  createConditions(dbCon)
  createWildLifeSize(dbCon)
  createWildLifeStrikes(dbCon)
}
# Creating all tables in database
createAllTables(dbCon)
```

```{r validateTableCreation, echo=FALSE, warning=FALSE, eval=FALSE}
# Part 4.g: Validating the table creation

# Function to describe the table
# @param: dbCon - database connection to connect to
describeTable <- function(dbCon, table) {
  query <- sprintf("DESCRIBE %s", table)
  return (dbGetQuery(dbCon, query))
}

# Function to validate the airports table
# Validates the columns created by describing the table.
# @param: dbCon - database connection to connect to
validateAirportsTable <- function(dbCon) {
  airportsTable <- describeTable(dbCon, airportsTableName)
  # Validating column count.
  expect_equal(nrow(airportsTable), 4)
  # Validating column names
  expect_equal(airportsTable$Field,
               c("aid", "airportName", "airportState", "airportCode"))
  # Validating column types
  # Airport code is varchar 5 because maximum possible airport code is 5 letter code.
  expect_equal(airportsTable$Type, c("int", "text", "text", "varchar(5)"))
  # Validating column keys
  expect_equal(airportsTable$Key, c("PRI", "", "", ""))
  # Validating column default values
  expect_equal(airportsTable$Default, c(NA, NA, NA, "ZZZ"))
  # Validating column extra values
  expect_equal(airportsTable$Extra, c("auto_increment", "", "", ""))
  # Validating column null values
  expect_equal(airportsTable$Null, c("NO", "NO", "NO", "NO"))
}

# Function to validate the flight table.
# Validates the columns created by describing the table.
# @param: dbCon - database connection to connect to
validateFlightTable <- function(dbCon) {
  flightTable <- describeTable(dbCon, flightsTableName)
  # Validating column count.
  expect_equal(nrow(flightTable), 6)
  # Validating column names
  expect_equal(
    flightTable$Field,
    c(
      "fid",
      "date",
      "originAirport",
      "airlineName",
      "aircraftType",
      "isHeavy"
    )
  )
  # Validating column types
  expect_equal(flightTable$Type,
               c("int", "date", "int", "text", "text", "tinyint(1)"))
  # Validating column keys
  expect_equal(flightTable$Key, c("PRI", "", "MUL", "", "", ""))
  # Validating column default values
  expect_equal(all(is.na(flightTable$Default)), TRUE)
  # Validating column extra values
  expect_equal(flightTable$Extra, c("auto_increment", "", "", "", "", ""))
  # Validating column null values
  expect_equal(flightTable$Null, c("NO", "YES", "NO", "NO", "NO", "YES"))
}

# Function to validate the condition table.
# Validates the columns created by describing the table.
# @param: dbCon - database connection to connect to
validateConditionTable <- function(dbCon) {
  conditionTable <- describeTable(dbCon, conditionsTableName)
  expect_equal(nrow(conditionTable), 3)
  expect_equal(conditionTable$Field,
               c("cid", "sky_condition", "explanation"))
  expect_equal(conditionTable$Type, c("int", "text", "text"))
  expect_equal(conditionTable$Key, c("PRI", "", ""))
  expect_equal(all(is.na(conditionTable$Default)), TRUE)
  expect_equal(conditionTable$Extra, c("auto_increment", "", ""))
  expect_equal(conditionTable$Null, c("NO", "NO", "YES"))
}

# Function to validate the wildlife size table.
# Validates the columns created by describing the table.
# @param: dbCon - database connection to connect to
validateWildLifeSizeTable <- function(dbCon) {
  wildlifeSizeTable <- describeTable(dbCon, wildlifeSizeTableName)
  expect_equal(nrow(wildlifeSizeTable), 2)
  expect_equal(wildlifeSizeTable$Field, c("wlId", "size"))
  expect_equal(wildlifeSizeTable$Type, c("int", "text"))
  expect_equal(wildlifeSizeTable$Key, c("PRI", ""))
  expect_equal(all(is.na(wildlifeSizeTable$Default)), TRUE)
  expect_equal(wildlifeSizeTable$Extra, c("auto_increment", ""))
  expect_equal(wildlifeSizeTable$Null, c("NO", "NO"))
}

# Function to validate the wildlife.strikes table.
# Validates the columns created by describing the table.
# @param: dbCon - database connection to connect to
validateWildlifeStrikesTable <- function(dbCon) {
  wildLifeStrikesTable <- describeTable(dbCon, widlifeStrikesTableName)
  expect_equal(nrow(wildLifeStrikesTable), 6)
  expect_equal(
    wildLifeStrikesTable$Field,
    c("iid", "fid", "wlsize", "impact", "altitude", "conditions")
  )
  expect_equal(wildLifeStrikesTable$Type,
               c("int", "int", "int", "text", "int", "int"))
  expect_equal(wildLifeStrikesTable$Key,
               c("PRI", "MUL", "MUL", "", "", "MUL"))
  expect_equal(all(is.na(wildLifeStrikesTable$Default)), TRUE)
  expect_equal(wildLifeStrikesTable$Extra,
               c("auto_increment", "", "", "", "", ""))
  expect_equal(wildLifeStrikesTable$Null,
               c("NO", "NO", "NO", "NO", "NO", "NO"))
}


# Function to validate the table creation for all tables
# @param: dbCon - database connection to connect to
validateTableCreation <- function(dbCon) {
  tryCatch({
    print("Starting validations of create table statements using describe table")
    validateAirportsTable(dbCon)
    validateFlightTable(dbCon)
    validateConditionTable(dbCon)
    validateWildLifeSizeTable(dbCon)
    validateWildlifeStrikesTable(dbCon)
    print("Validations of create table statements using describe table successfull")
  }, error = function(e) {
    print("Error in validating table creations")
    print(e)
  })
}


# Function to validate the insert query
# @param: dbCon - database connection to connect to
# @param: insertQuery - insert query to validate
# @return: TRUE if the insertion is successful, FALSE otherwise
validateInsertion <- function(dbCon, insertQuery) {
  tryCatch({
    dbExecute(dbCon, insertQuery)
    return(TRUE)
  }, error = function(e) {
    return(FALSE)
  })
}


# Validates airport table creation through insertion of sample data
# @param: dbCon - database connection to connect to
validateInsertOnAirport <- function(dbCon) {
  # Valid airport insertion
  validAirportInsert <- sprintf(
    "INSERT INTO %s (aid, airportName, airportState) VALUES (1,  'Valid Airport', 'Valid State')",
    airportsTableName
  )
  
  expect_true(validateInsertion(dbCon, validAirportInsert))
  
  # Invalid airport insertion with a duplicate primary key
  invalidAirportInsert <- sprintf(
    "INSERT INTO %s (aid, airportName, airportState) VALUES (1, 'Invalid Airport', 'Invalid State')",
    airportsTableName
  )
  expect_false(validateInsertion(dbCon, invalidAirportInsert))
}

# Validates flights table creation through insertion of sample data
# @param: dbCon - database connection to connect to
validateInsertOnFlights <- function(dbCon) {
  # Valid flight insertion with correct foreign key to 'airport'
  validFlightInsert <- sprintf(
    "INSERT INTO %s (date, originAirport, airlineName, aircraftType, isHeavy) VALUES ('2024-01-01', '1', 'airline', 'aircraft', 1)",
    flightsTableName
  )
  expect_true(validateInsertion(dbCon, validFlightInsert))
  
  # Invalid flight insertion with incorrect foreign key to 'airport'
  invalidFlightInsert <- sprintf(
    "INSERT INTO %s (date, originAirport, airlineName, aircraftType, isHeavy) VALUES ('2024-01-01', '2', 'airline', 'aircraft', 1)",
    flightsTableName
  )
  expect_false(validateInsertion(dbCon, invalidFlightInsert))
}

# Validates wildlifesize table creation through insertion of sample data
# @param: dbCon - database connection to connect to
validateInsertOnWildlifeSize <- function(dbCon) {
  # Valid wildlife Size insertion
  validWildlifeSizeInsertion <- sprintf("INSERT INTO %s (wlId, size) VALUES (1, 'Small')",
                                        wildlifeSizeTableName)
  expect_true(validateInsertion(dbCon, validWildlifeSizeInsertion))
  
  # Invalid wildlife Size insertion with duplicate primary key
  inValidWildlifeSizeInsertion <- sprintf("INSERT INTO %s (wlId, size) VALUES (1, 'Large')",
                                          wildlifeSizeTableName)
  expect_false(validateInsertion(dbCon, inValidWildlifeSizeInsertion))
}


# Validates condition table creation through insertion of sample data
# @param: dbCon - database connection to connect to
validateInsertOnCondition <- function(dbCon) {
  # Valid condition insertion
  validConditionInsertion <- sprintf(
    "INSERT INTO %s (cid, sky_condition, explanation) VALUES (1, 'Clear', 'Clear sky')",
    conditionsTableName
  )
  expect_true(validateInsertion(dbCon, validConditionInsertion))
  
  # Invalid condition insertion with duplicate primary key
  invalidConditionInsertion <- sprintf(
    "INSERT INTO %s (cid, sky_condition, explanation) VALUES (1, 'Cloudy', 'Cloudy sky')",
    conditionsTableName
  )
  expect_false(validateInsertion(dbCon, invalidConditionInsertion))
  
}

# Validates wildlife strikes table creation through insertion of sample data
# @param: dbCon - database connection to connect to
validateInsertOnStrikes <- function(dbCon) {
  # Valid wildlife.strikes insertion
  validWildlifeStrikesInsertion <- sprintf(
    "INSERT INTO %s (iid, fid, wlsize, impact, altitude, conditions) VALUES (1, 1, 1, 'Impact', 1000, 1)",
    widlifeStrikesTableName
  )
  expect_true(validateInsertion(dbCon, validWildlifeStrikesInsertion))
  
  # Invalid wildlife.strikes insertion with incorrect foreign key to 'flights'
  invalidWildlifeStrikesInsertion <- sprintf(
    "INSERT INTO %s (iid, fid, wlsize, impact, altitude, conditions) VALUES (2, 2, 1, 'Impact', 1000, 1)",
    widlifeStrikesTableName
  )
  expect_false(validateInsertion(dbCon, invalidWildlifeStrikesInsertion))
  
  # Invalid wildlife.strikes insertion with incorrect foreign key to 'wlsize'
  invalidWildlifeStrikesInsertion <- sprintf(
    "INSERT INTO %s (iid, fid, wlsize, impact, altitude, conditions) VALUES (2, 1, 2, 'Impact', 1000, 1)",
    widlifeStrikesTableName
  )
  expect_false(validateInsertion(dbCon, invalidWildlifeStrikesInsertion))
  
  # Invalid wildlife.strikes insertion with incorrect foreign key to 'conditions'
  invalidWildlifeStrikesInsertion <- sprintf(
    "INSERT INTO %s (iid, fid, wlsize, impact, altitude, conditions) VALUES (2, 1, 1, 'Impact', 1000, 2)",
    widlifeStrikesTableName
  )
  expect_false(validateInsertion(dbCon, invalidWildlifeStrikesInsertion))
}

cleanUpTestData <- function(dbCon) {
  tables <- c(
    widlifeStrikesTableName,
    flightsTableName,
    airportsTableName,
    conditionsTableName,
    wildlifeSizeTableName
  )
  for (table in tables) {
    invisible(dbExecute(dbCon, sprintf("DELETE FROM %s", table)))
  }
}


# Validates table creation through sample data insertion.
validateTableCreationThroughDataInsertion <- function(dbCon) {
  print("Starting validations of create table statements using actual data insertions")
  validateInsertOnAirport(dbCon)
  validateInsertOnFlights(dbCon)
  validateInsertOnWildlifeSize(dbCon)
  validateInsertOnCondition(dbCon)
  validateInsertOnStrikes(dbCon)
  cleanUpTestData(dbCon)
  print("Completed validations of create table statements using actual data insertions")
}
validateTableCreation(dbCon)
validateTableCreationThroughDataInsertion(dbCon)
```

```{r loadCSVData, echo=FALSE,warning=FALSE, eval= TRUE}
# Part 5: Loading CSV data into dataframe.

# referredFrom: http://artificium.us/lessons/06.r/l-6-302-bulkload-data-into-db/l-6-302.html#Load_CSV_Data
bds.raw <- read.csv(file = "BirdStrikesData-V4-SuF24.csv",
                    header = TRUE,
                    stringsAsFactors = FALSE)
```

## Insert Data To Tables
### Clean Up CSV Data
```{r cleanUpData, echo=TRUE,warning=FALSE, eval= TRUE}
# Part 6: Inserting data into the tables

  # Function to replace empty values with sentinel values
  # @param: columnValue - current column value
  # @param: sentinelValue - sentinel value to replace.
  replaceEmptyValues <- function(columnValue, sentinelValue) {
    # if column value is NA or empty or N/A, replace with sentinel value
    ifelse(
      is.na(columnValue) |
        columnValue == "" | columnValue == "N/A",
      sentinelValue,
      columnValue
    )
  }

# Function to clean up the data frame with sentinel values before inserting
# @param: dataFrame - data frame to clean up
# @return: cleaned up data frame
cleanUpData <- function(dataFrame) {
  neededColumns <- c(
    "iid",
    "aircraft",
    "flight_date",
    "airline",
    "dep_airport",
    "origin_state",
    "wildlife_size",
    "sky_conditions",
    "altitude_ft",
    "heavy_flag",
    "impact"
  )
  # Getting only the needed columns
  dataFrame <- dataFrame[, neededColumns]
  
  # Removing rows with NA in iid
  dataFrame <- dataFrame[!is.na(dataFrame$iid), ]
  
  # Defining sentinel values for each column.
  sentinelValues <- list(
    aircraft = "Unknown Aircraft",
    flight_date = "Unknown",
    airline = "Unknown Airline",
    dep_airport = "Unknown Airport",
    origin_state = "Unknown State",
    wildlife_size = "Unknown",
    sky_conditions = "Unknown",
    impact = "Unknown",
    heavy_flag = "Unknown",
    
    # Replacing unknown altitude to 0 since database needs value >=0.
    altitude_ft = 0
  )
  
  # Replacing empty values with sentinel values
  dataFrame[names(sentinelValues)] <- Map(replaceEmptyValues, dataFrame[names(sentinelValues)], sentinelValues)
  
  # Converting from string to date data type
  dataFrame$flight_date <- ifelse(
    dataFrame$flight_date == "Unknown",
    dataFrame$flight_date,
    as.character(as.Date(dataFrame$flight_date, format = "%m/%d/%y"))
  )
  
  # Removing comma from altitude_ft and converting to numeric
  dataFrame$altitude_ft <- as.numeric(gsub(",", "", dataFrame$altitude_ft))
  dataFrame$altitude_ft[is.na(dataFrame$altitude_ft)] <- 0
  
  # Making TRUE if the aircraft is a "heavy" aircraft, FALSE otherwise
  # as per the requirement.
  dataFrame$heavy_flag <- ifelse(dataFrame$heavy_flag == "Yes", TRUE, FALSE)
  return(dataFrame)
}
```

### Insert Data In Batches
```{r insertDataInBatches, echo=TRUE,warning=FALSE, eval= TRUE}
# Part 6: Inserting data into the tables

# Insert into database in batches
# @param: dbCon - database connection to connect to
# @param: batchSize - batch size to insert into the database
# @param: initialQuery - insert query with table and column names
# @param: values - values to insert into the database
insertInBatches <- function(dbCon, batchSize, initialQuery, values) {
  numBatches <- ceiling(length(values) / batchSize)
  for (i in 1:numBatches) {
    startIdx <- (i - 1) * batchSize + 1
    endIdx <- min(i * batchSize, length(values))
    batchValues <- values[startIdx:endIdx]
    completeQuery <- paste(initialQuery, paste(batchValues, collapse = ","))
    invisible(dbExecute(dbCon, completeQuery))
  }
}
```

### Insert Data Into Airports Table
```{r insertDataIntoAirports, echo=TRUE,warning=FALSE, eval= TRUE}
# Part 6: Inserting data into the tables

# Insert into airports table
# @param: dbCon - database connection to connect to
# @param: dataFrame - data frame to insert into the database
# @param: batchSize - batch size to insert into the database
insertIntoAirports <- function(dbCon, dataFrame, batchSize) {
  airports <- unique(dataFrame[c("dep_airport", "origin_state")])
  if (nrow(airports) > 0) {
    query <- sprintf("INSERT INTO %s (airportName, airportState) VALUES",
                     airportsTableName)
    
    # referredFrom: https://ademos.people.uic.edu/Chapter4.html
    values <- apply(airports, 1, function(row) {
      sprintf("('%s', '%s')",
              # Replacing single quote with double quote to avoid sql errors.
              gsub("'", "''", row["dep_airport"])
              ,
              gsub("'", "''", row["origin_state"]))
    })
    insertInBatches(dbCon, batchSize, query, values)
  }
}
```

### Insert Data Into Conditions Table
```{r insertDataIntoConditions, echo=TRUE,warning=FALSE, eval= TRUE}
# Part 6: Inserting data into the tables


# Insert into conditions table
# @param: dbCon - database connection to connect to
# @param: dataFrame - data frame to insert into the database
# @param: batchSize - batch size to insert into the database
insertIntoConditions <- function(dbCon, dataFrame, batchSize) {
  conditions <- unique(dataFrame[c("sky_conditions")])
  if (nrow(conditions) > 0) {
    query <- sprintf("INSERT INTO %s (sky_condition,explanation) VALUES",
                     conditionsTableName)
    values <- apply(conditions, 1, function(row) {
      # Replacing single quote with double quote to avoid sql errors.
      sprintf("('%s', '')", gsub("'", "''", row["sky_conditions"]))
    })
    insertInBatches(dbCon, batchSize, query, values)
  }
}
```

### Insert Data Into Wildlife Size Table
```{r insertDataIntoWildlifeSize, echo=TRUE,warning=FALSE, eval= TRUE}
# Part 6: Inserting data into the tables

# Insert into wildlife size table
# @param: dbCon - database connection to connect to
# @param: dataFrame - data frame to insert into the database
insertIntoWildLifeSize <- function(dbCon, dataFrame, batchSize) {
  wildlifeSize <- unique(dataFrame[c("wildlife_size")])
  if (nrow(wildlifeSize) > 0) {
    query <- sprintf("INSERT INTO %s (size) VALUES", wildlifeSizeTableName)
    values <- apply(wildlifeSize, 1, function(row) {
      # Replacing single quote with double quote to avoid sql errors.
      sprintf("('%s')", gsub("'", "''", row["wildlife_size"]))
    })
    insertInBatches(dbCon, batchSize, query, values)
  }
}
```

### Insert Data Into Flights Table
```{r insertDataIntoFlights, echo=TRUE,warning=FALSE, eval= TRUE}
# Part 6: Inserting data into the tables

# Gets the airport id from given airport name and state
# @param: airportMapping - airport mapping data frame
# @param: airportName - airport name
# @param: airportState - airport state
getAirportId <- function(airportMapping,
                         airportName,
                         airportState) {
  # Getting mathcing row by equating airportName and airportState.
  matchingRow <- airportMapping[airportMapping$airportName == airportName &
                                  airportMapping$airportState == airportState, ]
  return(matchingRow$aid[1])
}

# Insert into flights table
# @param: dbCon - database connection to connect to
# @param: dataFrame - data frame to insert into the database
# @param: batchSize - batch size to insert into the database
insertIntoFlights <- function(dbCon, dataFrame, batchSize) {
  flights <- unique(dataFrame[c("flight_date",
                                "dep_airport",
                                "origin_state",
                                "airline",
                                "aircraft",
                                "heavy_flag")])
  query <- sprintf(
    "INSERT INTO %s (date, originAirport, airlineName, aircraftType, isHeavy) VALUES",
    flightsTableName
  )
  
  airportMapping <- dbGetQuery(dbCon,
                               sprintf(
                                 "SELECT aid, airportName,airportState FROM %s",
                                 airportsTableName
                               ))
  
  values <- apply(flights, 1, function(row) {
    # If flight date is unknown insert it as NULL.
    flightDateToCreate <- if (row["flight_date"] == "Unknown")
      "NULL"
    else
      sprintf("'%s'", row["flight_date"])
    
    sprintf(
      "(%s, %s, '%s', '%s', %s)"
      ,
      flightDateToCreate,
      getAirportId(airportMapping, row["dep_airport"], row["origin_state"])
      ,
      gsub("'", "''", row["airline"])
      ,
      gsub("'", "''", row["aircraft"])
      ,
      row["heavy_flag"]
    )
  })
  insertInBatches(dbCon, batchSize, query, values)
}

```

### Insert Data Into Wildlife Strikes Table
```{r insertDataIntoWildLifeStrikes, echo=TRUE,warning=FALSE, eval= TRUE}
# Part 6: Inserting data into the tables

# Gets flight id from given date, origin airport, airline name, aircraft type and if its heavy
# @param: flightMapping - flight mapping data frame
# @param: date - date of the flight
# @param: originAirport - origin airport of the flight
# @param: airlineName - airline name of the flight
# @param: aircraftType - aircraft type of the flight
# @param: isHeavy - if the flight is heavy
getFlightId <- function(flightMapping,
                        date,
                        originAirport,
                        airlineName,
                        aircraftType,
                        isHeavy) {
  # Converting dates to character to compare
  searchDate <- ifelse(date == "Unknown", NA, as.character(as.Date(date)))
  flightMapping$date <- as.character(flightMapping$date)
  
  # Converting to boolean to compare.
  searchHeavy <- as.logical(isHeavy)
  
  # If flight date is not known ignore and compare with everything else to get the matching row.
  matchingRow <- flightMapping[(is.na(searchDate) |
                                  flightMapping$date == searchDate) &
                                 flightMapping$originAirport == originAirport &
                                 flightMapping$airlineName == airlineName &
                                 flightMapping$aircraftType == aircraftType &
                                 flightMapping$isHeavy == searchHeavy, ]
  return(matchingRow$fid[1])
}

# Gets wild life size id from given wild life size
# @param: wildlifeSizeMapping - wildlife size mapping data frame
# @param: wildlifeSize - wildlife size
getWildLifeSizeId <- function(wildlifeSizeMapping, wildlifeSize) {
  matchingRow <- wildlifeSizeMapping[wildlifeSizeMapping$size == wildlifeSize, ]
  return(matchingRow$wlId[1])
}

# Gets condition id from given sky condition
# @param: conditionMapping - condition mapping data frame
# @param: skyCondition - sky condition
getConditionId <- function(conditionMapping, skyCondition) {
  matchingRow <- conditionMapping[conditionMapping$sky_condition == skyCondition, ]
  return(matchingRow$cid[1])
}




# Insert into wildlife.strikes table
# @param: dbCon - database connection to connect to
# @param: dataFrame - data frame to insert into the database
# @param: batchSize - batch size to insert into the database
insertIntoWildLifeStrikes <- function(dbCon, dataFrame, batchSize) {
  flightMapping <- dbGetQuery(
    dbCon,
    sprintf(
      "SELECT fid, date, originAirport, airlineName, aircraftType, isHeavy FROM %s",
      flightsTableName
    )
  )
  
  wildlifeSizeMapping <- dbGetQuery(dbCon,
                                    sprintf("SELECT wlId, size FROM %s", wildlifeSizeTableName))
  
  conditionMapping <- dbGetQuery(dbCon,
                                 sprintf("SELECT cid, sky_condition FROM %s", conditionsTableName))
  
  airportsMapping <- dbGetQuery(dbCon,
                                sprintf(
                                  "SELECT aid, airportName,airportState FROM %s",
                                  airportsTableName
                                ))
  
  query <- sprintf(
    "INSERT INTO %s (iid,fid, wlsize, impact, altitude, conditions) VALUES",
    widlifeStrikesTableName
  )
  
  values <- apply(dataFrame, 1, function(row) {
    flightId <- getFlightId(flightMapping,
                            row["flight_date"]
                            ,
                            getAirportId(airportsMapping
                                         , row["dep_airport"]
                                         , row["origin_state"])
                            ,
                            row["airline"]
                            ,
                            row["aircraft"]
                            ,
                            row["heavy_flag"])
    
    wildlifeSizeId <- getWildLifeSizeId(wildlifeSizeMapping, row["wildlife_size"])
    conditionId <- getConditionId(conditionMapping, row["sky_conditions"])
    
    sprintf(
      "(%s,%s, %s, '%s', %s,%s)"
      ,
      row["iid"]
      ,
      flightId
      ,
      wildlifeSizeId
      ,
      gsub("'", "''", row["impact"])
      ,
      row["altitude_ft"]
      ,
      conditionId
    )
  })
  insertInBatches(dbCon, batchSize, query, values)
}

```

### Insert Data Into Required Tables
```{r insertDataIntoTables, echo=TRUE,warning=FALSE, eval= TRUE}
# Part 6: Inserting data into the tables

# Insert values into the database
# @param: dbCon - database connection to connect to
# @param: dataFrame - data frame to insert into the database
insertValuesIntoDatabase <- function(dbCon, dataFrame) {
  batchSize <- 100
  dataFrame <- cleanUpData(dataFrame)
  insertIntoAirports(dbCon, dataFrame, batchSize)
  insertIntoConditions(dbCon, dataFrame, batchSize)
  insertIntoWildLifeSize(dbCon, dataFrame, batchSize)
  insertIntoFlights(dbCon, dataFrame, batchSize)
  insertIntoWildLifeStrikes(dbCon, dataFrame, batchSize)
}

insertValuesIntoDatabase(dbCon, bds.raw)
```

```{r validateDataInsertion, echo=FALSE, warning=FALSE, eval=FALSE}
# Part 7: Validating the data insertion

# Function to get data from tables
# @param: dbCon - database connection to connect to
# @param: table - table to get data from
# @param: limit - limit of rows to get
displayTable <- function(dbCon, table, limit) {
  query <- sprintf("SELECT * FROM %s LIMIT %s", table, limit)
  return (dbGetQuery(dbCon, query))
}

#Joins all the tables to display the first 5 rows
displayJoinOfAllTables <- function(dbCon) {
  query <- sprintf(
    "SELECT ws.iid,
       ws.fid,
       ws.wlsize,
       ws.conditions,
       ws.altitude,
       ws.impact,
       f.date,
       f.originAirport,
       f.aircraftType,
       f.airlineName,
       f.isHeavy,
       a.airportName,
       a.airportState,
       a.airportCode,
       wls.size,
       c.sky_condition,
       c.explanation

FROM %s ws
         INNER JOIN %s f ON ws.fid = f.fid
         INNER JOIN %s a ON f.originAirport = a.aid
         INNER JOIN %s wls ON ws.wlsize = wls.wlId
         INNER JOIN %s c ON ws.conditions = c.cid
LIMIT 5",
widlifeStrikesTableName,
flightsTableName,
airportsTableName,
wildlifeSizeTableName,
conditionsTableName
  )
  return (dbGetQuery(dbCon, query))
}

# Prints the first 5 rows of each table to validate the data insertion
# @param: dbCon - database connection to connect to
validateDataInsertion <- function(dbCon) {
  tryCatch({
    print("Starting validations of data insertions")
    limit <- 5
    airportTable <- displayTable(dbCon, airportsTableName, limit)
    conditionTable <- displayTable(dbCon, conditionsTableName, limit)
    wildlifeSizeTable <- displayTable(dbCon, wildlifeSizeTableName, limit)
    flightTable <- displayTable(dbCon, flightsTableName, limit)
    wildlifeStrikesTable <- displayTable(dbCon, widlifeStrikesTableName, limit)
    completeJoinTable <- displayJoinOfAllTables(dbCon)
    
    print(head(airportTable))
    print(head(conditionTable))
    print(head(wildlifeSizeTable))
    print(head(flightTable))
    print(head(wildlifeStrikesTable))
    print(head(completeJoinTable))
    print("Validations of data insertions successfull")
  }, error = function(e) {
    print("Error in validating data insertions")
    print(e)
  })
}

validateDataInsertion(dbCon)
```

## Top States With Strikes
```{r topStateWithStrikes, echo=FALSE,warning=FALSE,eval=TRUE}
# Part 8: Top 5 states with strikes

# Function to get the top 5 states with the greatest number of wildlife
# strike incidents
# @param: dbCon - database connection to connect to
topStatesWithStrikes <- function(dbCon) {
  # Query to group by state and count the number of strikes
  query <- sprintf(
    "SELECT a.airportState, COUNT(*) as strikes
  FROM %s a
  JOIN %s f ON a.aid = f.originAirport
  JOIN %s ws ON f.fid = ws.fid
  GROUP BY a.airportState
  ORDER BY strikes DESC
  LIMIT 5",
  airportsTableName,
  flightsTableName,
  widlifeStrikesTableName
  )
  
  resultTable <- dbGetQuery(dbCon, query)
  # referredFrom: https://www.rdocumentation.org/packages/knitr/versions/1.48/topics/kable
  kable(
    resultTable,
    format = "html",
    col.names = c("State", "Number of Strikes")
  ) %>%
    # referredFrom: https://www.rdocumentation.org/packages/kableExtra/versions/1.4.0/topics/kable_styling
    kable_styling(
      # striped is used to get color contrast between rows.
      bootstrap_options = c("striped"),
      full_width = FALSE,
      position = "center"
    ) %>%
    # changing the header row.
    row_spec(
      0,
      bold = TRUE,
      color = "white",
      background = "#557A95"
    )
}

topStatesWithStrikes(dbCon)
```

## Analysis by Airport
```{r airportsWithBelowAverageStrikes, echo=FALSE,warning=FALSE,eval=TRUE}
# Part 9: Airports with below average number of wildlife strikes.

# Function to get the airports with below average number of wildlife strikes
# Lists the names of the top 5 airports and the number of incidents for each
# @param: dbCon - database connection to connect to
airportsBelowAverageStrikes <- function(dbCon) {
  query <- sprintf(
    # First gets the strike count for each airport and then gets the average strike count.
    # Then gets the airports with strike count less than the average strike count.
    "WITH strikeCount AS (
      SELECT
        a.aid,
        a.airportName,
        COUNT(*) as strikeCount
      FROM %s ws
      JOIN %s f ON ws.fid = f.fid
      JOIN %s a ON f.originAirport = a.aid
      GROUP BY a.aid, a.airportName
    ),
    averageStrike AS (
      SELECT AVG(strikeCount) as avgStrike
      FROM strikeCount
    )
    SELECT
      sc.airportName,
      sc.strikeCount
    FROM strikeCount sc
    WHERE sc.StrikeCount < (
    SELECT avgStrike
    FROM averageStrike
    )
    ORDER BY sc.StrikeCount DESC
    LIMIT 5",
    widlifeStrikesTableName,
    flightsTableName,
    airportsTableName
  )
  
  resultTable <- dbGetQuery(dbCon, query)
  kable(
    resultTable,
    format = "html",
    col.names = c("Airport Name", "Number of Incidents")
  ) %>%
    kable_styling(
      # striped is used to get color contrast between rows.
      bootstrap_options = c("striped"),
      full_width = FALSE,
      position = "center"
    ) %>%
    # changing the header row.
    row_spec(
      0,
      bold = TRUE,
      color = "white",
      background = "#557A95"
    )
}

airportsBelowAverageStrikes(dbCon)
```


## Analysis by Year
```{r strikesByWildlifeSize, echo=FALSE,warning=FALSE,eval=TRUE}
# Part 10: Analysis to to find the (total) number of "small", "medium", and "large" wildlife strikes per year.

# Function to get the number of small, medium and large wildlife strikes per year
# @param: dbCon - database connection to connect to
strikesByWildlifeSize <- function(dbCon) {
  
  query <- query <- sprintf(
    # Gets the strike count grouped by year and size.
    # Then gets the total number of strikes per year.
    "
    WITH yearlyStrikes AS (
      SELECT
        YEAR(f.date) as strikeYear,
        wl.size,
        COUNT(*) as strikeCount
      FROM %s ws
      JOIN %s f ON ws.fid = f.fid
      JOIN %s wl ON ws.wlsize = wl.wlId
      GROUP BY YEAR(f.date), wl.size
      ORDER BY strikeYear
    )
    SELECT
      strikeYear,
      MAX(CASE WHEN size = 'Small' THEN strikeCount ELSE 0 END) as small,
      MAX(CASE WHEN size = 'Medium' THEN strikeCount ELSE 0 END) as medium,
      MAX(CASE WHEN size = 'Large' THEN strikeCount ELSE 0 END) as large,
      MAX(CASE WHEN size = 'Unknown' THEN strikeCount ELSE 0 END) as unknown,
      SUM(strikeCount) as total
    FROM yearlyStrikes
    GROUP BY strikeYear
    ORDER BY strikeYear ASC
  ",
  widlifeStrikesTableName,
  flightsTableName,
  wildlifeSizeTableName
  )
  return (dbGetQuery(dbCon, query))
}

strikesByWildlifeSizeFrame <- strikesByWildlifeSize(dbCon)
kable(
  strikesByWildlifeSizeFrame,
  format = "html",
  col.names = c("Year", "Small", "Medium", "Large", "Unknown", "Total")
) %>%
  kable_styling(
    # striped is used to get color contrast between rows.
    bootstrap_options = c("striped"),
    full_width = FALSE,
    position = "center"
  ) %>%
  # changing the header row.
  row_spec(
    0,
    bold = TRUE,
    color = "white",
    background = "#557A95"
  )
```


## Trend by Year
```{r visualiseTrendByYear, echo=FALSE,warning=FALSE,eval=TRUE}
#. Part 11: Visualizing trend per year using plot.

# Function to visualize the trend of wildlife strikes per year
# @param: dataFrame - data frame with the number of small, medium and large wildlife strikes per year
visualiseTrendByYear <- function(dataFrame) {
  # referredFrom: https://www.geeksforgeeks.org/r-line-graphs/
  # Ignores null/N/A values of data for year.
  plot(
    dataFrame$strikeYear,
    dataFrame$total,
    # to plot lines and points
    type = "o",
    col = "darkblue",
    # to set filled circlers
    pch = 19,
    # to set line width
    lwd = 2,
    xlab = "Year",
    ylab = "Total Number of Strikes",
    main = "Wildlife Strike Incidents by Year",
    ylim = c(0, max(dataFrame$total) * 1.3),
  )
  
  
  # to add grid lines
  # lty = 2 is used to set dashed lines
  grid(lty = 2, col = "gray80")
  
  # to add labels to the points
  text(
    # x location
    dataFrame$strikeYear,
    # y location
    dataFrame$total + 350,
    labels = dataFrame$total,
    # size of text
    cex = 0.8,
    col = "darkblue"
  )
  
  # Adds a legend to the plot
  legend(
    "topleft",
    legend = "Actual Strikes",
    col = "darkblue",
    # used to denote a solid line
    lty = 1,
    # used to denote a filled circle
    pch = 19,
    bg = "white",
    # used to set box width
    box.lwd = 1
  )
}


visualiseTrendByYear(strikesByWildlifeSizeFrame)
```

```{r createUpdateLogTable , echo=FALSE,warning=FALSE, eval= TRUE}
# Part 12: Creating update log table

# Function to create update log table
# logs are stored in changes as follows:
# {<iid>:[{"column":"columnNameThatGotUpdated","oldValue":oldValue,"newValue":newValue}, {<anotherChange>]}
# @param: dbCon - database connection to connect to
createUpdateLogTable <- function(dbCon) {
  query <- sprintf(
    "CREATE TABLE IF NOT EXISTS %s (
    logId INT PRIMARY KEY AUTO_INCREMENT,
    modificationType VARCHAR(20) NOT NULL,
    tableName VARCHAR(50) NOT NULL,
    updatedAt TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    changes JSON NOT NULL
);",
updateLog
  )
  invisible(dbExecute(dbCon, query))
}
createUpdateLogTable(dbCon)
```

```{r createProcedureForUpdatingWildLifeStrike, echo=FALSE,warning=FALSE, eval= TRUE}
# Part 12: Creating procedure to update wildlife strikes

dropProcedureForUpdatingWildLifeStrike <- function(dbCon) {
  query <- sprintf("DROP PROCEDURE IF EXISTS UpdateWildlifeStrike")
  invisible(dbExecute(dbCon, query))
}

# Function to create procedure for updating wildlife strikes
# Procedure updates the wildlife strikes table and logs the changes in the update log table
# Updates are not done if the values are same as the old values or if the new values are NULL
# @param: dbCon - database connection to connect to
createProcedureForUpdatingWildLifeStrike <- function(dbCon) {
  dropProcedureForUpdatingWildLifeStrike(dbCon)
  query <- sprintf(
    "
  CREATE PROCEDURE UpdateWildlifeStrike(
    IN strikeId INT,
    IN newFlightId INT,
    IN newSize INT,
    IN newImpact TEXT,
    IN newAltitude INT,
    IN newCondition INT
)
BEGIN

    DECLARE oldFlightId INT;
    DECLARE oldSize INT;
    DECLARE oldImpact TEXT;
    DECLARE oldAltitude INT;
    DECLARE oldCondition INT;
    DECLARE changesArray JSON DEFAULT JSON_ARRAY();
    DECLARE changeForIid JSON;
    DECLARE columnKey VARCHAR(6) DEFAULT 'column';
    DECLARE oldValueKey VARCHAR(8) DEFAULT 'oldValue';
    DECLARE newValueKey VARCHAR(8) DEFAULT 'newValue';

    SELECT fid,wlsize, impact, altitude, conditions
    INTO oldFlightId,oldSize, oldImpact, oldAltitude, oldCondition
    FROM %s
    WHERE iid = strikeId;



    IF newFlightId IS NOT NULL AND oldFlightId != newFlightId  THEN
       SET changesArray = JSON_ARRAY_APPEND(changesArray, '$',
            JSON_OBJECT(
                columnKey, 'fid',
                oldValueKey, oldFlightId,
                newValueKey, newFlightId
            )
        );
    END IF;

    IF newSize IS NOT NULL AND oldSize != newSize THEN
        SET changesArray = JSON_ARRAY_APPEND(changesArray, '$',
            JSON_OBJECT(
                columnKey, 'wlsize',
                oldValueKey, oldSize,
                newValueKey, newSize
            )
        );
    END IF;

    IF newImpact IS NOT NULL AND oldImpact != newImpact THEN
       SET changesArray = JSON_ARRAY_APPEND(changesArray, '$',
            JSON_OBJECT(
                columnKey, 'impact',
                oldValueKey, oldImpact,
                newValueKey, newImpact
            )
        );
    END IF;

     IF newAltitude IS NOT NULL AND newAltitude > 0 AND oldAltitude != newAltitude  THEN
       SET changesArray = JSON_ARRAY_APPEND(changesArray, '$',
            JSON_OBJECT(
                columnKey, 'altitude',
                oldValueKey, oldAltitude,
                newValueKey, newAltitude
            )
        );
    END IF;

    IF newCondition IS NOT NULL AND oldCondition != newCondition  THEN
       SET changesArray = JSON_ARRAY_APPEND(changesArray, '$',
            JSON_OBJECT(
                columnKey, 'conditions',
                oldValueKey, oldCondition,
                newValueKey, newCondition
            )
        );
    END IF;


    IF JSON_LENGTH(changesArray) > 0 THEN
        SET changeForIid = JSON_OBJECT(CAST(strikeId AS CHAR), changesArray);
        INSERT INTO update_log (
            modificationType,
            tableName,
            changes
        )
        VALUES (
            'UPDATE',
            'wildlife.strikes',
            changeForIid
        );

        UPDATE %s
        SET
            fid = IFNULL(newFlightId,fid),
            wlsize = IFNULL(newSize, wlsize),
            impact = IFNULL(newImpact, impact),
            altitude = IFNULL(newAltitude, altitude),
            conditions = IFNULL(newCondition, conditions)
        WHERE iid = strikeId;
    END IF;

END
  ", widlifeStrikesTableName, widlifeStrikesTableName)

invisible(dbExecute(dbCon, query))
}
createProcedureForUpdatingWildLifeStrike(dbCon)
```

```{r validateUpdateWildLifeStrike, echo=FALSE,warning=FALSE, eval= FALSE}
# Part 12: Validating update wildlife strikes procedure

# Function to validate the update wildlife strikes procedure
# Validates by calling update procedure and checking if the values are updated
# Also validates if the log entry is created
# @param: dbCon - database connection to connect to
validateUpdateWildLifeStrikeProcedure <- function(dbCon) {
  query <- sprintf(
    "SELECT iid, fid,wlsize, impact, altitude, conditions
           FROM %s
           ORDER BY iid
           LIMIT 1",
    widlifeStrikesTableName
  )
  orginalStrike <- dbGetQuery(dbCon, query)
  
  # increasing altitude by 10.
  newAltitude = orginalStrike$altitude + 10
  
  updateQuery <-  sprintf(
    "
    CALL UpdateWildlifeStrike(
      %s,
      NULL,
      NULL,
      NULL,
      %s,
      NULL
    )",
    orginalStrike$iid,
    newAltitude
  )
  
  invisible(dbExecute(dbCon, updateQuery))
  
  
  updatedStrike <- dbGetQuery(
    dbCon,
    sprintf(
      "SELECT iid, fid,wlsize, impact, altitude, conditions
            FROM %s
            WHERE iid = %d",
      widlifeStrikesTableName,
      orginalStrike$iid
    )
  )
  
  expect_equal(updatedStrike$fid, orginalStrike$fid)
  expect_equal(updatedStrike$wlsize, orginalStrike$wlsize)
  expect_equal(updatedStrike$impact, orginalStrike$impact)
  expect_equal(updatedStrike$altitude, newAltitude)
  
  
  updateLogEntry <- dbGetQuery(dbCon,
                               sprintf("SELECT * FROM %s ORDER BY updatedAt DESC LIMIT 1", updateLog))
  
  expect_equal(updateLogEntry$tableName, "wildlife.strikes")
  expect_equal(updateLogEntry$modificationType, "UPDATE")
  
  # referredFrom: https://stackoverflow.com/questions/51143588/convert-string-into-json-string-and-parsing-in-r
  changes <- fromJSON(updateLogEntry$changes)
  entry <- changes[[as.character(orginalStrike$iid)]]
  expect_equal(entry$column, "altitude")
  expect_equal(entry$oldValue, orginalStrike$altitude)
  expect_equal(entry$newValue, newAltitude)
}

print("Starting validations for Update Procdedure")
validateUpdateWildLifeStrikeProcedure(dbCon)
print("Successfully completed validations for Update Procdedure")
```

```{r closeConnection, echo=FALSE, warning=FALSE, eval=TRUE}
invisible(dbDisconnect(dbCon))
```
